---
title: "Scripps's Murrelet Egg Size model"
author: "Amelia J. DuVall & Marcela Todd"
date: "4/11/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## load libraries
library(here)
library(tidyverse)
library(janitor)
library(ggplot2)
library(lubridate)
library(viridis)
library(lme4)
library(faraway)
library(sjPlot)
library(RLRsim)
```

This is `r paste0("v.", (Sys.Date()))`

# Introduction
This document details steps taken to model Scripps's Murrelet (*Synthliboramphus scrippsi*) egg size at Santa Barbara Island within Channel Islands National Park from 2009-2017.  

# Load and format data 
```{r data}
egg <- read.csv(here("data", "SCMU_egg_data.csv")) 
covars <- read.csv(here("data", "covariates", "covars.csv"))

## join covariate data with egg data by year
SCMUdf <- left_join(egg, covars, by = "Year") %>%
  filter(TrueOrder == TRUE) %>% # egg order known only
  select(Year, Observer, Plot, Size, EggOrder, ANCHL, BEUTI, NPGO, ONI, PDO, SST) %>%
  as_tibble()
```

# Null Intercept-Only Model with 2 random effects
This model includes observer and plot as random effects, but does not include any covariates.
```{r null_model}
## run model
nm <- lmer(Size ~ 1 + (1 | Observer) + (1 | Plot), data = SCMUdf, REML = TRUE)

## look at model output and estimates
sumary(nm)
coef(nm) # these are the coefficients
ranef(nm) # these are the random effects
## you can store the model results to objects
obs.ranef <- ranef(nm)$Observer 
plot.ranef <- ranef(nm)$Plot
## the mean of these values should be close to 0
mean(obs.ranef[[1]])
mean(plot.ranef[[1]])

## quick model diagnostics
## extract predicted values and plot
preds <- predict(nm) 
ggplot() + 
  geom_histogram(mapping = aes(preds)) + 
  theme_minimal() 
# we want these to look normally distributed

## extract residuals and plot
resids <- residuals(nm) 
ggplot() + 
  geom_histogram(mapping = aes(resids)) + 
  theme_minimal()
# we want these to look normally distributed

# qq resids
qqnorm(resids, main = "QQ plot (residuals)", las = 1, pch = 16)
qqline(resids)

## plot residuals versus fitted values
yh <- fitted(nm)
plot(yh, resids, las = 1, pch = 16,
     xlab = "Fitted", ylab = "Residuals",
     main = "Residuals vs fitted")
abline(h=0, lty = "dashed")
```

# Fit Candidate Models
Based on the LRTs, we only included Plot as a random effect (see below). 
```{r mods}
## create data frame specifying predictors to include
predictors <- as.data.frame(matrix(c(FALSE, TRUE), 2, 7)) # 7 potential predictors (includes EggOrder)

## add column names
cov_names <- colnames(predictors) <- colnames(SCMUdf[,5:11])

## create set of all possible combinations
full_set <- expand.grid(predictors) # 128 combinations

## select models with correlated predictors
ii <- which(full_set$ANCHL + full_set$NPGO == 2 |
              full_set$ANCHL + full_set$PDO == 2 |
              full_set$ANCHL + full_set$SST == 2 |
              full_set$BEUTI + full_set$PDO == 2 |
              full_set$NPGO + full_set$ONI == 2 |
              full_set$NPGO + full_set$PDO == 2 |
              full_set$NPGO + full_set$SST == 2 |
              full_set$PDO + full_set$SST == 2) # 96 models

## create reduced set of models and convert to a matrix for easier indexing
use_set <- as.matrix(full_set[-ii,]) 

## number of models in set
(n_mods <- nrow(use_set)) # 32 models out of potential 128

## create empty matrix for storing results
mod_res <- matrix(NA, n_mods, 1)
colnames(mod_res) <- c("AIC")

## fit models and store AIC & BIC
for(i in 1:n_mods) {
  if(i == 1) {
    fmla <- "Size ~ 1 + (1 | Plot)"
  } else {
    fmla <- paste("Size ~ (1 | Plot) +", paste(cov_names[use_set[i,]], collapse = " + "))
  }
  mod_fit <- lmer(as.formula(fmla), data = SCMUdf, REML = TRUE)
  mod_res[i,"AIC"] <- AIC(mod_fit)
}

## create empty matrix for storing results
delta_res <- matrix(NA, n_mods, 1)
colnames(delta_res) <- c("deltaAIC")

## convert IC to deltaIC
delta_res[,"deltaAIC"] <- mod_res[,"AIC"] - min(mod_res[,"AIC"])
(delta_res <- round(delta_res, 2)) # round results

## "best" models from our set
cov_names[use_set[12,]] # Egg order, BEUTI, NPGO
cov_names[use_set[32,]] # Egg order, BEUTI, ONI, SST
cov_names[use_set[10,]] # Egg order, NPGO (>2 AIC)
cov_names[use_set[20,]] # Egg order, ANCHL, BEUTI, ONI (>2 AIC)

## run top models
topmod1 <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod2 <- lmer(Size ~ EggOrder + BEUTI + ONI + SST + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod3 <- lmer(Size ~ EggOrder + NPGO + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod4 <- lmer(Size ~ EggOrder + ANCHL + BEUTI + ONI + (1 | Plot), data = SCMUdf, REML = TRUE)

## Model selection table
AIC.tab <- matrix(NA, nrow = 4, ncol = 3) # 4 rows for 4 top models
AIC.tab[1,1] <- AIC(topmod1) # AIC for topmod1 in first row, first column
AIC.tab[2,1] <- AIC(topmod2) # AIC for topmod2 in second row, first column
AIC.tab[3,1] <- AIC(topmod3) # AIC for topmod2 in second row, first column
AIC.tab[4,1] <- AIC(topmod4) # AIC for topmod2 in second row, first column
AIC.tab[,2] <- AIC.tab[,1] - min(AIC.tab[,1]) # calculate delta AIC
AIC.tab[,3] <- exp(-0.5*AIC.tab[,2])/(sum(exp(-0.5*AIC.tab[,2]))) # calculate model weights
colnames(AIC.tab) <- c("AIC", "deltaAIC", "model_weights")
print(AIC.tab)
```

# Top Models
Here we look at the top competitive models. 

## Top Model 1
```{r topmod1}
topmod1 <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Plot), data = SCMUdf, REML = TRUE)
summary(topmod1)  
```
## Top Model 2
```{r topmod2}
topmod2 <- lmer(Size ~ EggOrder + BEUTI + ONI + SST + (1 | Plot), data = SCMUdf, REML = TRUE)
summary(topmod2)
```

# Likelihood Ratio Tests
We used LRTs using the top model to test the support for inclusion of random effects (Plot, Observer). There are NAs in the observer data from 2015. These NAs need to be removed prior to completing LRT tests. See https://cran.r-project.org/web/packages/RLRsim/RLRsim.pdf for info.
```{r likelihoodratio}
SCMUdf2 <- SCMUdf[-c(which(is.na(SCMUdf$Observer==TRUE))),]

## top model
bm_both <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Observer) + (1 | Plot), data = SCMUdf2, REML = FALSE)

## run model with plot RE only
bm_plot <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Plot), data = SCMUdf2, REML = FALSE)

## run model with obs RE only
bm_obs <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Observer), data = SCMUdf2, REML = FALSE)

## Exact RLRT test
# m is the reduced model containing only the RE to be tested (the random effect set to zero under the null hypothesis). mA and Mo are the models under the alternative and the null, respectively. 

# observer set to zero under the null hypothesis
exactRLRT(m = bm_obs, mA = bm_both, m0 = bm_plot, seed = 16)

# plot set to zero under the null hypothesis 
exactRLRT(m = bm_plot, mA = bm_both, m0 = bm_obs, seed = 16)
```
Based on a strict alpha = 0.05, we would keep plot (p ~ 0.0198) but eliminate observer (p ~ 1).

# Model Diagnostics
These diagnostics are done for the global model. 

## Residuals/Fitted Plots

### Histogram of Predicted Values
```{r d1}
## extract predicted values and plot
preds <- predict(topmod2)
ggplot() + 
  geom_histogram(mapping = aes(preds), bins = 15) + # set bins 
  theme_minimal()
```
Since we assumed our data are normal, we want to see an approximately normal distribution of predicted values.

### Histogram of Residuals
```{r d2}
## extract residuals and plot
resids <- residuals(topmod2)
ggplot() + 
  geom_histogram(mapping = aes(resids), bins = 20) + 
  theme_minimal()
```
Since we assumed our data are normal, we want to see an approximately normal distribution of residuals (differences between observed and predicted values of data).

### Model Coefficients
```{r d3}
## extract coeffs and random effects
coef(topmod2) # this include fixed and random effects
ranef_pl <- ranef(topmod2)$Plot # plot random effect only

## look at data going into random effects
table(SCMUdf$Plot)
```
We can extract our model coefficients (for fixed and random effects) and look at them. 

### Q-Q Plots
```{r d4}
# qq resids
qqnorm(resids, main = "QQ plot (residuals)", las = 1, pch = 16)
qqline(resids)

# qq Plot RE
qqnorm(unlist(ranef_pl), main = "QQ plot (Plot RE)", las = 1, pch = 16)
qqline(unlist(ranef_pl))
```
We want our points to fall approximately on the diagonal lines. 

### Fitted v Residuals
```{r d5}
## plot residuals versus fitted values
yh <- fitted(topmod2)
plot(yh, resids, las = 1, pch = 16,
     xlab = "Fitted", ylab = "Residuals",
     main = "Residuals vs fitted")
abline(h=0, lty = "dashed")
```
We assume our errors are normally distributed with constant variance. We want this plot to look like a scattershot of points, without any evidence of trends. 

## Levene's test
We can formally test the assumption of homogenous variance via the Levene's Test, which compares the absolute values of the residuals among groups. 
```{r lev}
## split residuals into 2 groups
g1 <- resids[yh <= median(yh)]
g2 <- resids[yh > median(yh)]

## Levene's test
var.test(g1, g2)
```
There is no justification to reject the null hypothesis that the residuals are equal. F is close to 1 and it is within the 95% confidence interval. 

## Autocorrelation
We also assume our errors are independent (e.g., not correlated). An ACF plot can be used to look for autocorrelation. 
```{r acf}
# calculate the ACF for lags between 1 and 10 
autocorrelation <- acf(resids, lag.max= 10, plot = FALSE)

# Plot figure
plot(autocorrelation,
     main="Autocorrelation",
     xlab="Lag Parameter",
     ylab="ACF")
```
The first value with 0 lag will always be autocorrelated because it's stacked on itself. But after that, we want to see the values within the blue dotted lines. There does not appear to be autocorrelation in the residuals. 

# Identifying Outliers
https://qerm514.github.io/website/labs/week_03/diagnostics_and_errors.html#unusual_observations
https://qerm514.github.io/website/homework/week_03/hw_03_diagnostics_key.pdf
Calculate the studentized residuals to look for outliers
```{r outliers}
## get studentized residuals
(stud_e <- rstudent(topmod2))

## get sample size
n <- nrow(SCMUdf)

## Bonferroni correction: alpha/n
alpha <- 0.05/n

## critical t value
degf <- n - length(coef(bm1))-1 # should be more due to REs?
t_crit <- qt(1 - alpha/2, degf)

## compare t_stud to t_crit
sum(stud_e > t_crit, na.rm = TRUE)
```

## Cook's Distance
```{r cook}
## Cook's D
cook <- cooks.distance(bm1)

# Plot the Cook's Distance using the traditional 4/n criterion
sample_size <- nrow(SCMUdf)
plot(cook, pch="*", cex=2, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = 4/sample_size, col="red")  # add cutoff line
text(x=1:length(cook)+1, y=cook, labels=ifelse(cook>4/sample_size, names(cook),""), col="red")  # add labels
```

# Prediction
```{r predict}
topmod1 <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod2 <- lmer(Size ~ EggOrder + BEUTI + ONI + SST + (1 | Plot), data = SCMUdf, REML = TRUE)

#we want predictions with all predictors but one held constant, and then we'll do this one-at-a-time for each of the predictors
# this will allow us to produce nice plots looking at the marginal effect of each predictor 

#first, set up a dataset with everything at its mean value (except EggOrder)
set.seed(1)
SCMU.null <- SCMUdf[c(1:200),]
SCMU.null$EggOrder <- c(rep("Egg1",100),rep("Egg2",100))
SCMU.null$BEUTI <- mean(SCMUdf$BEUTI) 
SCMU.null$NPGO <- mean(SCMUdf$NPGO) 
SCMU.null$ONI <- mean(SCMUdf$ONI) 
SCMU.null$ANCHL <- mean(SCMUdf$ANCHL) 
SCMU.null$PDO <- mean(SCMUdf$PDO)
SCMU.null$SST <- mean(SCMUdf$SST)
#I'm pretty sure you need some values of plot and observer but it doesn't matter which ones because we're not going to condition on these

SCMU.null$Plot <- sample(SCMUdf$Plot,200,replace = TRUE)
#SCMU.null$Observer <- sample(SCMUdf$Observer,200,replace = TRUE)

```



```{r predict BEUTI}
#then vary just one predictor at a time for prediction. For example, create the dataset SCMU.BEUTI that will be used for predictions where the only thing that values is BEUTI 
SCMU.BEUTI <- SCMU.null
SCMU.BEUTI$BEUTI <- rep(seq(from = min(SCMUdf$BEUTI),to = max(SCMUdf$BEUTI),length.out = 100),2)

#PREDICT FOR SCMU.BEUTI
#Pull together the random effects (do we want the models with)

# obs.sd.1 <- as.data.frame(VarCorr(bm1))$sdcor[1]
# plot.sd.1 <- as.data.frame(VarCorr(bm1))$sdcor[2]
# resid.sd.1 <- as.data.frame(VarCorr(bm1))$sdcor[3]
# 
# obs.sd.2 <- as.data.frame(VarCorr(bm2))$sdcor[1]
# plot.sd.2 <- as.data.frame(VarCorr(bm2))$sdcor[2]
# resid.sd.2 <- as.data.frame(VarCorr(bm2))$sdcor[3]
# 
# obs.sd.3 <- as.data.frame(VarCorr(bm3))$sdcor[1]
# plot.sd.3 <- as.data.frame(VarCorr(bm3))$sdcor[2]
# resid.sd.3 <- as.data.frame(VarCorr(bm3))$sdcor[3]

plot.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[1]
resid.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[2]

plot.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[1]
resid.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[2]

sims <- 1000

# pv <- matrix(nrow = sims, ncol = nrow(SCMU.BEUTI))
# for(i in 1:sims){
#   #choose a model 
#   model <- which(rmultinom(n = 1, size = 1,prob = c(AIC.tab[,3]))==1)
#   if(model == 1){
#     #we simulate conditioning on no specific random effects levels
#     y <- unlist(simulate(bm1))
#     bmod <- refit(bm1,y)
#     pv[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.BEUTI) + rnorm(1,0,sd=obs.sd.1) + rnorm(1,0,sd=plot.sd.1) + rnorm(1,0,sd=resid.sd.1)
#   }
#   if(model == 2){
#     #we simulate conditioning on no specific random effects levels
#     y <- unlist(simulate(bm2))
#     bmod <- refit(bm2,y)
#     pv[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.BEUTI) + rnorm(1,0,sd=obs.sd.2) + rnorm(1,0,sd=plot.sd.2) + rnorm(1,0,sd=resid.sd.2)
#   }
#   if(model == 3){
#     #we simulate conditioning on no specific random effects levels
#     y <- unlist(simulate(bm3))
#     bmod <- refit(bm3,y)
#     pv[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.BEUTI) + rnorm(1,0,sd=obs.sd.3) + rnorm(1,0,sd=plot.sd.3) + rnorm(1,0,sd=resid.sd.3)
#   }
# }  

## Marcela tried updating
pv.BEUTI <- matrix(nrow = sims, ncol = nrow(SCMU.BEUTI))
for(i in 1:sims){
  #choose a model 
  model <- which(rmultinom(n = 1, size = 1,prob = c(AIC.tab[,3]))==1)
  if(model == 1){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod))
    bmod <- refit(topmod2,y)
    pv.BEUTI[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.BEUTI) + rnorm(1,0,sd=plot.sd.1) + rnorm(1,0,sd=resid.sd.1)
  }
  if(model == 2){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod2))
    bmod <- refit(topmod2,y)
    pv.BEUTI[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.BEUTI) + rnorm(1,0,sd=plot.sd.2) + rnorm(1,0,sd=resid.sd.2)
  }
}  


##SJC added - you can do plots like this of the predictions and 95% CIs against the individual predictors 
plot(SCMU.BEUTI$BEUTI[1:100],y = apply(pv.BEUTI,2,mean)[1:100],xlab = "BEUTI",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.BEUTI$BEUTI[1:100],y = apply(pv.BEUTI,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.BEUTI$BEUTI[1:100],y = apply(pv.BEUTI,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)
  
```

```{r predict NPGO}

SCMU.NPGO <- SCMU.null
SCMU.NPGO$NPGO <- rep(seq(from = min(SCMUdf$NPGO),to = max(SCMUdf$NPGO),length.out = 100),2)

plot.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[1]
resid.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[2]

plot.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[1]
resid.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[2]

sims <- 1000

pv.NPGO <- matrix(nrow = sims, ncol = nrow(SCMU.NPGO))
for(i in 1:sims){
  #choose a model 
  model <- which(rmultinom(n = 1, size = 1,prob = c(AIC.tab[,3]))==1)
  if(model == 1){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod))
    bmod <- refit(topmod2,y)
    pv.NPGO[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.NPGO) + rnorm(1,0,sd=plot.sd.1) + rnorm(1,0,sd=resid.sd.1)
  }
  if(model == 2){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod2))
    bmod <- refit(topmod2,y)
    pv.NPGO[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.NPGO) + rnorm(1,0,sd=plot.sd.2) + rnorm(1,0,sd=resid.sd.2)
  }
}  


plot(SCMU.NPGO$NPGO[1:100],y = apply(pv.NPGO,2,mean)[1:100],xlab = "NPGO",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.NPGO$NPGO[1:100],y = apply(pv.NPGO,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.NPGO$NPGO[1:100],y = apply(pv.NPGO,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)
  
```
```{r predict ONI}

SCMU.ONI <- SCMU.null
SCMU.ONI$ONI <- rep(seq(from = min(SCMUdf$ONI),to = max(SCMUdf$ONI),length.out = 100),2)

plot.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[1]
resid.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[2]

plot.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[1]
resid.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[2]

sims <- 1000

pv.ONI <- matrix(nrow = sims, ncol = nrow(SCMU.ONI))
for(i in 1:sims){
  #choose a model 
  model <- which(rmultinom(n = 1, size = 1,prob = c(AIC.tab[,3]))==1)
  if(model == 1){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod))
    bmod <- refit(topmod2,y)
    pv.ONI[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.ONI) + rnorm(1,0,sd=plot.sd.1) + rnorm(1,0,sd=resid.sd.1)
  }
  if(model == 2){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod2))
    bmod <- refit(topmod2,y)
    pv.ONI[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.ONI) + rnorm(1,0,sd=plot.sd.2) + rnorm(1,0,sd=resid.sd.2)
  }
}  

plot(SCMU.ONI$ONI[1:100],y = apply(pv.ONI,2,mean)[1:100],xlab = "ONI",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.ONI$ONI[1:100],y = apply(pv.ONI,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.ONI$ONI[1:100],y = apply(pv.ONI,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)
  
```
```{r predict SST}

SCMU.SST <- SCMU.null
SCMU.SST$SST <- rep(seq(from = min(SCMUdf$SST),to = max(SCMUdf$SST),length.out = 100),2)

plot.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[1]
resid.sd.1 <- as.data.frame(VarCorr(topmod))$sdcor[2]

plot.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[1]
resid.sd.2 <- as.data.frame(VarCorr(topmod2))$sdcor[2]

sims <- 1000

pv.SST <- matrix(nrow = sims, ncol = nrow(SCMU.SST))
for(i in 1:sims){
  #choose a model 
  model <- which(rmultinom(n = 1, size = 1,prob = c(AIC.tab[,3]))==1)
  if(model == 1){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod))
    bmod <- refit(topmod2,y)
    pv.SST[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.SST) + rnorm(1,0,sd=plot.sd.1) + rnorm(1,0,sd=resid.sd.1)
  }
  if(model == 2){
    #we simulate conditioning on no specific random effects levels
    y <- unlist(simulate(topmod2))
    bmod <- refit(topmod2,y)
    pv.SST[i,] <- predict(bmod, re.form = ~0, newdata = SCMU.SST) + rnorm(1,0,sd=plot.sd.2) + rnorm(1,0,sd=resid.sd.2)
  }
}  

plot(SCMU.SST$SST[1:100],y = apply(pv.SST,2,mean)[1:100],xlab = "SST",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.SST$SST[1:100],y = apply(pv.SST,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.SST$SST[1:100],y = apply(pv.SST,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)
  
```


```{r combine plots}
parmfrow=c(2, 2)

plot(SCMU.BEUTI$BEUTI[1:100],y = apply(pv.BEUTI,2,mean)[1:100],xlab = "BEUTI",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.BEUTI$BEUTI[1:100],y = apply(pv.BEUTI,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.BEUTI$BEUTI[1:100],y = apply(pv.BEUTI,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)

plot(SCMU.NPGO$NPGO[1:100],y = apply(pv.NPGO,2,mean)[1:100],xlab = "NPGO",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.NPGO$NPGO[1:100],y = apply(pv.NPGO,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.NPGO$NPGO[1:100],y = apply(pv.NPGO,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)
  
plot(SCMU.ONI$ONI[1:100],y = apply(pv.ONI,2,mean)[1:100],xlab = "ONI",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.ONI$ONI[1:100],y = apply(pv.ONI,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.ONI$ONI[1:100],y = apply(pv.ONI,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)
  
plot(SCMU.SST$SST[1:100],y = apply(pv.SST,2,mean)[1:100],xlab = "SST",ylab = "Egg Size",type = "l",ylim = c(1500,2500))
lines(SCMU.SST$SST[1:100],y = apply(pv.SST,2,function(x)quantile(x,probs= 0.025))[1:100],lty=2)
lines(SCMU.SST$SST[1:100],y = apply(pv.SST,2,function(x)quantile(x,probs= 0.975))[1:100],lty=2)
  
```

