---
title: "Scripps's Murrelet Egg Size model"
author: "Amelia J. DuVall & Marcela Todd"
date: "4/11/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## load libraries
library(here)
library(tidyverse)
library(janitor)
library(ggplot2)
library(lubridate)
library(viridis)
library(lme4)
library(faraway)
library(sjPlot)
```

This is `r paste0("v.", (Sys.Date()))`

# Introduction
This document details steps taken to model Scripps's Murrelet (*Synthliboramphus scrippsi*) egg size at Santa Barbara Island within Channel Islands National Park from 2009-2017.  

Note: There are only 7 records for 2009. Should we include this year?  

# Load and format data 
```{r data}
egg <- read_csv(here("data", "SCMU_egg_data.csv"))
covars <- read_csv(here("data", "covariates", "covars.csv"))

## join covariate data with egg data by year
df <- left_join(egg, covars, by = "Year") %>%
  filter(TrueOrder == TRUE) %>% # egg order known only
  select(Year, Observer, Plot, Size, EggOrder, ANCHL, BEUTI, NPGO, ONI, PDO, SST)
```

# Null Intercept-Only Model
This model includes observer and plot as random effects, but does not include any covariates.
```{r null_model}
nm <- lmer(Size ~ 1 + (1 | Observer) + (1 | Plot), data = df)
sumary
coef.nm <- coef(nm)
ranef(nm)
# mean(ranef(nm)$Observer) # should be close to 0


## output table
sjPlot::tab_model(nm)

## quick model diagnostics
## extract predicted values and plot
preds <- predict(nm) 
ggplot() + 
  geom_histogram(mapping = aes(preds)) + 
  theme_minimal()

## extract residuals and plot
resids <- residuals(nm) 
ggplot() + 
  geom_histogram(mapping = aes(resids)) + 
  theme_minimal()

## Q-Q Plots
## set plot area
par(mai = c(0.9, 0.9, 0.6, 0.1),
    omi = c(0, 0, 0, 0),
    mfrow = c(1,2), cex.lab = 1.2)

# qq resids
qqnorm(resids, main = "QQ plot (residuals)", las = 1, pch = 16)
qqline(resids)

## plot residuals versus fitted values
yh <- fitted(nm)
plot(yh, resids, las = 1, pch = 16,
     xlab = "Fitted", ylab = "Residuals",
     main = "Residuals vs fitted")
abline(h=0, lty = "dashed")
```

# Egg Order-only Model
This model includes observer and plot as random effects and egg order as a fixed effect. 
```{r null_model}
order.mod <- lmer(Size ~ EggOrder + (1 | Observer) + (1 | Plot), data = df)
sumary(order.mod)
coef(summary(order.mod))
VarCorr(order.mod)

## output table
sjPlot::tab_model(order.mod)

## plotting
sjPlot::plot_model(order.mod, 
                   show.values = TRUE, show.p = TRUE) +
  theme_minimal()
```


# Fit Candidate Models
```{r mods}
## create data frame specifying predictors to include
predictors <- as.data.frame(matrix(c(FALSE, TRUE), 2, 7)) # 7 potential predictors (includes EggOrder)

## add column names
cov_names <- colnames(predictors) <- colnames(df[,5:11])

## create set of all possible combinations
full_set <- expand.grid(predictors) # 128 combinations

## select models with correlated predictors
ii <- which(full_set$SST + full_set$NPGO == 2 |
              full_set$NPGO + full_set$PDO == 2 |
              full_set$BEUTI + full_set$PDO == 2 |
              full_set$ANCHL + full_set$SST == 2 |
              full_set$ONI + full_set$SST == 2 |
              full_set$ANCHL + full_set$ONI == 2 |
              full_set$ANCHL + full_set$PDO == 2 |
              full_set$PDO + full_set$SST == 2 |
              full_set$ONI + full_set$PDO == 2) # 98 models

## create reduced set of models and convert to a matrix for easier indexing
use_set <- as.matrix(full_set[-ii,]) # 30 models

## number of models in set
(n_mods <- nrow(use_set)) # 30 models out of potential 128

## create empty matrix for storing results
mod_res <- matrix(NA, n_mods, 2)
colnames(mod_res) <- c("AIC", "BIC")

## fit models and store AIC & BIC
for(i in 1:n_mods) {
  if(i == 1) {
    fmla <- "Size ~ 1 + (1 | Observer) + (1 | Plot)"
  } else {
    fmla <- paste("Size ~ (1 | Observer) + (1 | Plot) +", paste(cov_names[use_set[i,]], collapse = " + "))
  }
  mod_fit <- lmer(as.formula(fmla), data = df)
  mod_res[i,"AIC"] <- AIC(mod_fit)
  mod_res[i,"BIC"] <- BIC(mod_fit) 
}

## create empty matrix for storing results
delta_res <- matrix(NA, n_mods, 2)
colnames(delta_res) <- c("deltaAIC", "deltaBIC")

## convert IC to deltaIC
delta_res[,"deltaAIC"] <- mod_res[,"AIC"] - min(mod_res[,"AIC"])
delta_res[,"deltaBIC"] <- mod_res[,"BIC"] - min(mod_res[,"BIC"])
(delta_res <- round(delta_res, 2)) # round results

## create df with mod results
mp <- as.data.frame(use_set)

for (i in 1:length(mp)) {
   mp[[i]] <- str_replace(mp[[i]], "TRUE", colnames(mp)[i])
}

for (i in 1:length(mp)) {
   mp[[i]] <- str_replace(mp[[i]], "FALSE", " ")
}

mpfe <- mp %>%
  mutate(FEs = paste(EggOrder, ANCHL, BEUTI, NPGO, ONI, PDO, SST, sep = " "))

usmr <- mpfe %>%
  mutate(k = as.vector(rowSums(use_set) + 2)) %>% #2 check this
  mutate(modelno = 1:30) 

allm <- as.data.frame(delta_res) %>%
  mutate(modelno = 1:30) %>%
  arrange(deltaAIC) %>%
  left_join(usmr, by = "modelno") %>%
  dplyr::select(modelno, FEs, k, deltaAIC, deltaBIC)

## create df with top models
bestm <- allm %>%
  filter(deltaAIC <= 2) 
```


# Top Model
```{r bestmod}
bm <- lmer(Size ~ EggOrder + ANCHL + BEUTI + NPGO + (1 | Observer) + (1 | Plot), data = df)
summary(bm)
sumary(bm)
mm <- model.matrix(bm)

## output table
sjPlot::tab_model(bm)

## plotting
sjPlot::plot_model(bm, 
                   show.values = TRUE, show.p = TRUE) +
  theme_minimal()

## extract predicted values and plot
preds <- predict(bm)
ggplot() + 
  geom_histogram(mapping = aes(preds)) + 
  theme_minimal()

## extract residuals and plot
resids <- residuals(bm)
ggplot() + 
  geom_histogram(mapping = aes(resids)) + 
  theme_minimal()

## extract coeffs and random effects
coef(bm)
ranef_obs <- ranef(bm)$Observer
ranef_pl <- ranef(bm)$Plot

## estimated mean egg size
eta <- predict(bm)
mean(eta) # is this right?
```

# Model Diagnostics
```{r diagnostics}
## Q-Q Plots
## set plot area
par(mai = c(0.9, 0.9, 0.6, 0.1),
    omi = c(0, 0, 0, 0),
    mfrow = c(1,2), cex.lab = 1.2)

# qq resids
qqnorm(resids, main = "QQ plot (residuals)", las = 1, pch = 16)
qqline(resids)

# qq Plot RE
qqnorm(unlist(ranef_pl), main = "QQ plot (Plot RE)", las = 1, pch = 16)
qqline(unlist(ranef_pl))

# qq Observer RE
qqnorm(unlist(ranef_obs), main = "QQ plot (Observer RE)", las = 1, pch = 16)
qqline(unlist(ranef_obs))

## plot residuals versus fitted values
yh <- fitted(bm)
plot(yh, resids, las = 1, pch = 16,
     xlab = "Fitted", ylab = "Residuals",
     main = "Residuals vs fitted")
abline(h=0, lty = "dashed")
```


```{r lev}
## Levene's test
## split residuals into 2 groups
g1 <- resids[yh <= median(yh)]
g2 <- resids[yh > median(yh)]

## Levene's test
var.test(g1, g2)
# We would reject the null hypothesis that the variances are equal. 
```
```{r gof}
## Goodness of fit
## Pearson's X^2 statistic
X2 <- sum((success - yh)^2/yh)
df <- nn-6 # 4 fixed effects, 2 random effects

## likelihood ratio test
pchisq(X2, df = 1323, lower.tail = FALSE)
# large p-value, cannot reject H_0

## check for overdispersion 
c_hat <- deviance(bm)/df
# close to 1

## Likelihood ratio tests  
## run model with plot RE only
bm_plot <- glmer(Success ~ Type + (1 | Plot), data = SCMU, family = binomial)
## run model with year RE only
bm_yr <- glmer(Success ~ Type + (1 | Year), data = SCMU, family = binomial)
## run model with both REs (same as top model)

## conduct an LRT to see if the variance of the Plot RE is contributing useful info
test_1 <- 2 * (logLik(bm) - logLik(bm_yr))
pchisq(as.numeric(test_1), df = 1, lower.tail = FALSE)
# There is support for inclusion of Plot as an RE

## check for contribution of Year RE
test_2 <- 2 * (logLik(bm) - logLik(bm_plot))
pchisq(as.numeric(test_2), df = 1, lower.tail = FALSE)
# There is support for inclusion of Year as an RE

## Bootstrapping  to test for evidence against including multiple random effects in the same model
## set random seed 
set.seed(514)

## fit null model with no RE's 
nbm <- lm(Success ~ Type, data = SCMU)

## calculate likelihood ratio (difference in log-likelihood)
lambda <- 2 * (logLik(bm) - logLik(nbm))

## number of bootstrapped samples
nb <- 1000

## empty vector for storing LRT statistics
LRT_boot <- rep(NA, nb)

## bootstrapping
for(i in 1:nb) { # repeat nb times
  sim_data <- unlist(simulate(nbm)) # simulate data from null model
  m_null <- lm(sim_data ~ Type, data = SCMU) # fit null model to sim data 
  m_alt <- lmer(sim_data ~ Type + (1 | Year) + (1 | Plot), data = SCMU, REML = FALSE) # fit RE model
  LRT_boot[i] <- as.numeric(2*(logLik(m_alt) - logLik(m_null))) # calculate likelihood ratio 
}

## calculate approximate p-value
mean(LRT_boot > lambda)
# none of the bootstrapped samples had a test statistic larger than the original value of lambda
```
