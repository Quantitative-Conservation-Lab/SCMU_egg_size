---
title: "Scripps's Murrelet Egg Size model"
author: "Amelia J. DuVall & Marcela Todd"
date: "4/11/2021"
output: pdf_document
---

# Introduction
This document details steps taken to model Scripps's Murrelet (*Synthliboramphus scrippsi*) egg size at Santa Barbara Island within Channel Islands National Park from 2009-2017.  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

## load libraries and format data 
library(here)
library(tidyverse)
library(janitor)
library(ggplot2)
library(lubridate)
library(viridis)
library(lme4)
library(RLRsim)
library(faraway)
library(sjPlot)
library(forecast)

egg <- read.csv(here("data", "SCMU_egg_data.csv")) 
covars <- read.csv(here("data", "covariates", "covars.csv"))

## join covariate data with egg data by year
SCMUdf <- left_join(egg, covars, by = "Year") %>%
  filter(TrueOrder == TRUE) %>% # egg order known only
  filter(Size > 1210) %>% # removes the two LC outliers
  select(Year, Observer, Plot, Size, EggOrder, ANCHL, BEUTI, NPGO, ONI, PDO, SST) %>%
  as_tibble()
```

# Null Intercept-Only Model with 2 random effects
This model includes observer and plot as random effects, but does not include any covariates.
```{r null_model}
## run model
nm <- lmer(Size ~ 1 + (1 | Observer) + (1 | Plot), data = SCMUdf, REML = TRUE)

## look at model output and estimates
sumary(nm)
coef(nm) # these are the coefficients
ranef(nm) # these are the random effects
## you can store the model results to objects
obs.ranef <- ranef(nm)$Observer 
plot.ranef <- ranef(nm)$Plot
## the mean of these values should be close to 0
mean(obs.ranef[[1]])
mean(plot.ranef[[1]])

## quick model diagnostics
## extract predicted values and plot
preds <- predict(nm) 
ggplot() + 
  geom_histogram(mapping = aes(preds)) + 
  theme_minimal() 
# we want these to look normally distributed

## extract residuals and plot
resids <- residuals(nm) 
ggplot() + 
  geom_histogram(mapping = aes(resids)) + 
  theme_minimal()
# we want these to look normally distributed

# qq resids
qqnorm(resids, main = "QQ plot (residuals)", las = 1, pch = 16)
qqline(resids)

## plot residuals versus fitted values
yh <- fitted(nm)
plot(yh, resids, las = 1, pch = 16,
     xlab = "Fitted", ylab = "Residuals",
     main = "Residuals vs fitted")
abline(h=0, lty = "dashed")
```

# Remove Correlated Predictos & Find Global Model
```{r mods}
## create data frame specifying predictors to include
predictors <- as.data.frame(matrix(c(FALSE, TRUE), 2, 7)) # 7 potential predictors (includes EggOrder)

## add column names
cov_names <- colnames(predictors) <- colnames(SCMUdf[,5:11])

## create set of all possible combinations
full_set <- expand.grid(predictors) # 128 combinations

## select models with correlated predictors (see SCMU_egg_covariates.Rmd)
ii <- which(full_set$ANCHL + full_set$NPGO == 2 |
              full_set$ANCHL + full_set$ONI == 2 |
              full_set$ANCHL + full_set$PDO == 2 |
              full_set$BEUTI + full_set$ONI == 2 |
              full_set$BEUTI + full_set$PDO == 2 |
              full_set$NPGO + full_set$PDO == 2 |
              full_set$NPGO + full_set$SST == 2 |
              full_set$ONI + full_set$PDO == 2) # 98 models

## create reduced set of models and convert to a matrix for easier indexing
use_set <- as.matrix(full_set[-ii,]) 

## number of models in set
(n_mods <- nrow(use_set)) # 30 models out of potential 128

## find max number of predictors in a model
rowSums(use_set) # only one model with 4 predictors (72)

## which predictors are included in this model?
cov_names[use_set[26,]] # "EggOrder" "ANCHL"    "BEUTI"    "SST"  
```

# Likelihood Ratio Tests
We used LRTs using the global model to test the support for inclusion of random effects (Plot, Observer). There are NAs in the observer data from 2015. These NAs need to be removed prior to completing LRT tests. See https://cran.r-project.org/web/packages/RLRsim/RLRsim.pdf for info.
```{r likelihoodratio}
SCMUdf2 <- SCMUdf[-c(which(is.na(SCMUdf$Observer==TRUE))),]

## global model
bm_both <- lmer(Size ~ EggOrder + ANCHL + BEUTI + SST + (1 | Observer) + (1 | Plot), data = SCMUdf2, REML = FALSE)

## run model with plot RE only
bm_plot <- lmer(Size ~ EggOrder + ANCHL + BEUTI + SST + (1 | Plot), data = SCMUdf2, REML = FALSE)

## run model with obs RE only
bm_obs <- lmer(Size ~ EggOrder + ANCHL + BEUTI + SST + (1 | Observer), data = SCMUdf2, REML = FALSE)

## Exact RLRT test
# m is the reduced model containing only the RE to be tested (the random effect set to zero under the null hypothesis). mA and Mo are the models under the alternative and the null, respectively. 

# observer set to zero under the null hypothesis
exactRLRT(m = bm_obs, mA = bm_both, m0 = bm_plot, seed = 16)

# plot set to zero under the null hypothesis 
exactRLRT(m = bm_plot, mA = bm_both, m0 = bm_obs, seed = 16)
```

# Model Diagnostics
These diagnostics are done for the global model. 
```{r global}
## run global model
global_mod <- lmer(Size ~ EggOrder + ANCHL + BEUTI + SST + (1 | Plot), data = SCMUdf, REML = TRUE)
```

## Residuals/Fitted Plots

### Histogram of Predicted Values
```{r d1}
## extract predicted values and plot
preds <- predict(global_mod)
p1 <- ggplot() + 
  geom_histogram(mapping = aes(preds), bins = 15) + # set bins 
  theme_minimal() +
  xlab("Predicted Egg Size") + ylab("Count") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
p1
```
Since we assumed our data are normal, we want to see an approximately normal distribution of predicted values.

### Histogram of Residuals
```{r d2}
## extract residuals and plot
resids <- residuals(global_mod)
p2 <- ggplot() + 
  geom_histogram(mapping = aes(resids), bins = 15) +
  theme_minimal() +
  xlab("Residuals") + ylab("Count") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
p2
```
Since we assumed our data are normal, we want to see an approximately normal distribution of residuals (differences between observed and predicted values of data).

### Model Coefficients
```{r d3}
## extract coeffs and random effects
coef(global_mod) # this include fixed and random effects
ranef_pl <- ranef(global_mod)$Plot # plot random effect only

## look at data going into random effects
table(SCMUdf$Plot)
```
We can extract our model coefficients (for fixed and random effects) and look at them. 

### Q-Q Plots
```{r d4}
# qq resids
qqnorm(resids, main = "QQ plot (residuals)", las = 1, pch = 16)
qqline(resids)

## try ggplot code
qqresids <- as.data.frame(resids)
p3 <- ggplot(qqresids, aes(sample = resids)) + 
  geom_qq() + geom_qq_line() +
  theme_minimal() +
  xlab("Theoretical Quantiles") + ylab("Sample Quantiles") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ggtitle("QQ Plot (Residuals)")
p3

# qq Plot RE
qqnorm(unlist(ranef_pl), main = "QQ plot (Plot RE)", las = 1, pch = 16)

#legend("topleft", "D", bty="n")

# legend("topleft", "D", bty="n")

qqline(unlist(ranef_pl))

## try ggplot code
plotRE <- as.data.frame(unlist(ranef_pl))
p4 <- ggplot(plotRE, aes(sample = unlist(ranef_pl))) + 
  geom_qq() + geom_qq_line() +
  theme_minimal() +
  xlab("Theoretical Quantiles") + ylab("Sample Quantiles") +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5)) +
  ggtitle("QQ Plot (Plot Random Effect)")
p4
```
We want our points to fall approximately on the diagonal lines. 

```{r combineplots}
library(cowplot)
pp <- plot_grid(p1, p2, p3, p4, labels = c("A", "B", "C", "D"))
pp



```


### Fitted v Residuals
```{r d5}
## plot residuals versus fitted values
yh <- fitted(global_mod)
plot(yh, resids, las = 1, pch = 16,
     xlab = "Fitted", ylab = "Residuals",
     main = "Residuals vs fitted")
abline(h=0, lty = "dashed")
```
We assume our errors are normally distributed with constant variance. We want this plot to look like a scattershot of points, without any evidence of trends. 

## Levene's test
We can formally test the assumption of homogenous variance via the Levene's Test, which compares the absolute values of the residuals among groups. 
```{r lev}
## split residuals into 2 groups
g1 <- resids[yh <= median(yh)]
g2 <- resids[yh > median(yh)]

## Levene's test
var.test(g1, g2)
```
There is no justification to reject the null hypothesis that the residuals are equal. F is close to 1 and it is within the 95% confidence interval. 

## Autocorrelation
We also assume our errors are independent (e.g., not correlated). An ACF plot can be used to look for autocorrelation. 
```{r acf}
# calculate the ACF for lags between 1 and 10 
autocorrelation <- acf(resids, lag.max= 10, plot = FALSE)

# Plot figure
# plot(autocorrelation,
#      main="Autocorrelation",
#      xlab="Lag Parameter",
#      ylab="ACF")

## ggplot code
ggAcf(x = resids, lag.max = 10) +
  theme_minimal() +
  ylim(c(-0.1,1)) +
  ggtitle("Autocorrelation") +
  theme(plot.title = element_text(hjust = 0.5))
```
The first value with 0 lag will always be autocorrelated because it's stacked on itself. But after that, we want to see the values within the blue dotted lines. There does not appear to be autocorrelation in the residuals. 

# Identifying Outliers
https://qerm514.github.io/website/labs/week_03/diagnostics_and_errors.html#unusual_observations
https://qerm514.github.io/website/homework/week_03/hw_03_diagnostics_key.pdf
Calculate the studentized residuals to look for outliers
```{r outliers}
## get studentized residuals
(stud_e <- rstudent(global_mod))

## get sample size
n <- nrow(SCMUdf)

## Bonferroni correction: alpha/n
alpha <- 0.05/n

## critical t value
degf <- n - length(coef(global_mod))-1 # should be more due to REs?
t_crit <- qt(1 - alpha/2, degf)

## compare t_stud to t_crit
sum(stud_e > t_crit, na.rm = TRUE)
```

## Cook's Distance
```{r cook}
## Cook's D
cook <- cooks.distance(global_mod)

# Plot the Cook's Distance using the traditional 4/n criterion
sample_size <- nrow(SCMUdf)
plot(cook, pch="*", cex=2, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = 4/sample_size, col="red")  # add cutoff line
text(x=1:length(cook)+1, y=cook, labels=ifelse(cook>4/sample_size, names(cook),""), col="red")  # add labels
```


# Fit Candidate Models
```{r modsel}
## create empty matrix for storing results
mod_res <- matrix(NA, n_mods, 1)
colnames(mod_res) <- c("AIC")

## fit models and store AIC & BIC
for(i in 1:n_mods) {
  if(i == 1) {
    fmla <- "Size ~ 1 + (1 | Plot)"
  } else {
    fmla <- paste("Size ~ (1 | Plot) +", paste(cov_names[use_set[i,]], collapse = " + "))
  }
  mod_fit <- lmer(as.formula(fmla), data = SCMUdf, REML = TRUE)
  mod_res[i,"AIC"] <- AIC(mod_fit)
}

## create empty matrix for storing results
delta_res <- matrix(NA, n_mods, 1)
colnames(delta_res) <- c("deltaAIC")

## convert IC to deltaIC
delta_res[,"deltaAIC"] <- mod_res[,"AIC"] - min(mod_res[,"AIC"])
(delta_res <- round(delta_res, 2)) # round results

## "best" models from our set
cov_names[use_set[12,]] # Egg order, BEUTI, NPGO
cov_names[use_set[16,]] # Egg order, NPGO, ONI
cov_names[use_set[26,]] # Egg order, ANCHL, BEUTI, SST (>2 AIC)
cov_names[use_set[30,]] # Egg order, PDO, SST (>2 AIC)
cov_names[use_set[18,]] # Egg order, PDO (>2 AIC)
cov_names[use_set[24,]] # Egg order, BEUTI, SST (>2 AIC)

## run top models
topmod1 <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod2 <- lmer(Size ~ EggOrder + NPGO + ONI + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod3 <- lmer(Size ~ EggOrder + ANCHL + BEUTI + SST + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod4 <- lmer(Size ~ EggOrder + PDO + SST + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod5 <- lmer(Size ~ EggOrder + PDO + (1 | Plot), data = SCMUdf, REML = TRUE)
topmod6 <-lmer(Size ~ EggOrder + BEUTI + SST + (1 | Plot), data = SCMUdf, REML = TRUE)

## Model selection table
AIC.tab <- matrix(NA, nrow = 6, ncol = 3) # 6 rows for 6 top models
AIC.tab[1,1] <- AIC(topmod1) # AIC for topmod1 in first row, first column
AIC.tab[2,1] <- AIC(topmod2) # AIC for topmod2 in second row, first column
AIC.tab[3,1] <- AIC(topmod3) # AIC for topmod3 in second row, first column
AIC.tab[4,1] <- AIC(topmod4) # AIC for topmod4 in second row, first column
AIC.tab[5,1] <- AIC(topmod5) # AIC for topmod5 in second row, first column
AIC.tab[6,1] <- AIC(topmod6) # AIC for topmod6 in second row, first column
AIC.tab[,2] <- AIC.tab[,1] - min(AIC.tab[,1]) # calculate delta AIC
AIC.tab[,3] <- exp(-0.5*AIC.tab[,2])/(sum(exp(-0.5*AIC.tab[,2]))) # calculate model weights
colnames(AIC.tab) <- c("AIC", "deltaAIC", "model_weights")
print(AIC.tab)
```

# Top Models
Here we look at the top competitive models. 

## Top Model 1
```{r topmod1}
topmod1 <- lmer(Size ~ EggOrder + BEUTI + NPGO + (1 | Plot), data = SCMUdf, REML = TRUE)
summary(topmod1)  
```

## Top Model 2
```{r topmod2}
topmod2 <- lmer(Size ~ EggOrder + NPGO + ONI + (1 | Plot), data = SCMUdf, REML = TRUE)
summary(topmod2)
```
